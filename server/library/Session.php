<?php
defined('AUTOLOAD') or exit('No direct access!');
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*
 * Session
 *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*
 *
 * Manages session for the PHP session routines.
 *
 * @class     -   Session
 * @file      -   Session.php
 * @location  -   ./server/library/Session.php
 * @package   -   dailyd
 * @author    -   Alexander Vey <this.vey@gmail.com>
 *
 * @version   -   1.0
 */

/**
 * Session class
 */
class Session {

    /**
     * The initial data used to determine whether we should write anything.
     *
     * @var mixed (serializeable)
     */
    private static $_initial_data;

    /**
     * The lifetime of a session.
     *
     * @var int
     */
    private static $_lifetime;

    /**
     * Flag to delete the current stored session
     *
     * @var boolean
     */
    private static $_delete;

    /**
     * Flag to secure the current session by using SSL (https)
     *
     * @var boolean
     */
    private static $_secure;

    /**
     * Initialize the session handlers and setup the session environment.
     *
     * @param string $session_name [optional] name of the session
     *
     * @access public
     * @since 1.0
     */
    static function init($session_name = 'PDOSESSID') {
        // The default session is not secured
        self::$_secure = false;
        self::$_delete = false;

        // Secure session if this is an HTTPS connection
        if (is_https()) {
            self::$_secure = true;
        }

        // Set name
        session_name($session_name);

        // Set path and secure flag to the cookie values
        session_set_cookie_params(null, '/', null, self::$_secure);

        // Set the session life time
        self::$_lifetime = ini_get('session.gc_maxlifetime');

        // Set the session handlers
        session_set_save_handler(array(
                __CLASS__,
                'open'
        ), array(
                __CLASS__,
                'close'
        ), array(
                __CLASS__,
                'read'
        ), array(
                __CLASS__,
                'write'
        ), array(
                __CLASS__,
                'destroy'
        ), array(
                __CLASS__,
                'gc'
        ));

        // session::write gets called after object destruction, so our class isn't available.
        // Fix that by registering it as a shutdown function, before objects are destroyed.
        register_shutdown_function('session_write_close');

        return session_start();
    }

    static function regenerate_id($old, $new) {
        $session = SessionModel::createDirectly(array('id' => $old));
        if ($session) {
            $session->id = $new;
            $session->update();
        }
    }

    /**
     * Executed when opening a session.
     * This function does not need to do anything!
     */
    static function open($save_path, $session_name) {
        return true;
    }

    /**
     * Executed when closing a session.
     * This function does not need to do anything!
     */
    static function close() {
        return true;
    }

    /**
     * Read session data from the database to return into the $_SESSION global.
     * Verifies against a number of parameters for security purposes.
     *
     * @param string $session_id The id generated by PHP for the session.
     * @return string The retrieved session.
     */
    static function read($session_id) {
        // Get current fingerprint
        $fingerprint = Server::getFingerprint();

        // Read in session
        $session = SessionModel::createDirectly(array('id' => $session_id));

        // Verify session exists
        if (!$session) {
            self::$_initial_data = false;
            return false;
        }

        // Verify expiration time
        if (time() > $session->expires) {
            self::$_delete = true;
        }

        // Verify fingerprint
        if (!$session->fingerprint || $fingerprint != $session->fingerprint) {
            self::$_delete = true;
        }

        if (self::$_delete) {
            // Invalid session cause expired or not legal fingerprint
            $session->delete();
            return false;
        }

        // Do garbage collection, since PHP is bad at it
        $probability = ini_get('session.gc_probability');
        if (rand(1, 100) <= $probability) {
            self::gc(self::$_lifetime);
        }

        // save the initial data we loaded so we can write only if it's changed
        self::$_initial_data = $session->data;

        // but if the expiration is close (less than half the session lifetime away), null it out so the session always gets written so we extend the session
        if (($session->expires - (time())) < (self::$_lifetime / 2)) {
            self::$_initial_data = null;
        }

        return $session->data;
    }

    /**
     * Commit $_SESSION data to the database for this user.
     *
     * @param string $session_id The PHP-generated session id
     * @param string $data Data from session stored as a string
     */
    static function write($session_id, $data) {
        // default to writing the data only if it's changed
        if (self::$_initial_data !== $data) {
            $do_write = true;
        } else {
            $do_write = false;
        }

        if ($do_write) {
            // Check if the session already exists to update, insert if not
            $session = SessionModel::createDirectly(array('id' => $session_id));
            $do_update = true;
            if (!$session) {
                $session = new SessionModel();
                $session->id = $session_id;
                $do_update = false;
            }

            $session->data = $data;
            $session->expires = (time() + self::$_lifetime);
            $session->fingerprint = Server::getFingerprint();

            if ($do_update) {
                $session->update();
            } else {
                $session->save();
            }
        }
    }

    /**
     * Destroy stored session data by session id
     *
     * @param string $session_id The PHP generated session id
     * @return
     */
    static function destroy($session_id) {
        SessionModel::deleteDirectly(array('id' => $session_id), true);
        return true;
    }

    /**
     * Session garbage collection deletes expired sessions
     *
     * @param mixed $max_lifetime Unused - The session expiration time, in seconds.
     */
    static function gc($max_lifetime) {
        SessionModel::deleteDirectly(array('expires <' => time()));
        return true;
    }

    /**
     * Destroy session, session data and session cookie.
     */
    static function kill() {
        if (isset($_SESSION)) {
            // Unset all session data
            $_SESSION = array();
        }

        // Delete the session cookie as well
        if (/*ini_get('session.use_cookies') && */isset($_COOKIE[session_name()])) {
            $params = session_get_cookie_params();
            setcookie(session_name(), '', 1, $params['path'], $params['domain'], $params['secure'], $params['httponly']);
        }

        // Finally, destroy the session.
        session_destroy();
        return true;
    }

    //
    // Additional helper and utililty functions
    // --- NO CORE FUNCTIONALITY BELOW THIS ---
    //

    /**
     * Adds a value to a session set
     *
     * @param string $set Name of the set
     * @param mixed $value value to store
     * @param string $key Optional unique key for the set under which to store the value
     */
    static function add_to_set($set, $value, $key = null) {
        if (!isset($_SESSION[$set])) {
            $_SESSION[$set] = array();
        }
        if ($key) {
            $_SESSION[$set][$key] = $value;
        } else {
            $_SESSION[$set][] = $value;
        }
    }

    /**
     * Return a set of messages
     *
     * @param string $set The name of the message set
     * @param boolean $clear true to clear the messages from the session upon receipt
     * @return array An array of message strings
     */
    static function get_set($set, $clear = true) {
        if (!isset($_SESSION[$set])) {
            $set_array = array();
        } else {
            $set_array = $_SESSION[$set];
        }
        if ($clear) {
            unset($_SESSION[$set]);
        }
        return $set_array;
    }

}
